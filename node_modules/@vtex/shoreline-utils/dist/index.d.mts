import * as React from 'react';
import { ReactElement, Ref, ReactNode, ForwardedRef, CSSProperties as CSSProperties$1 } from 'react';
export { camelCase, isUppercase, kebabCase, lowerFirst, pascalCase, snakeCase, splitByCase, upperFirst } from 'scule';
export { default as invariant } from 'tiny-invariant';
export { default as warning } from 'tiny-warning';
import { StandardProperties, SvgProperties, VendorProperties } from 'csstype';
export { Globals as CSSGlobals, Property as CSSProperty, Pseudos as CSSPseudoSelectors } from 'csstype';

interface ElementWithRef extends ReactElement {
    ref: Ref<any>;
}
type Primitive = string | number | boolean | null | undefined;
type AnyFunction = (...args: any) => any;
type RenderProps = (node: ReactNode) => ReactNode;
type LiteralUnion<T, K extends Primitive = string> = T | (K & Record<never, never>);
type Recursive<T> = {
    [key: string]: T | Recursive<T>;
};
type AnyObject = Record<keyof any, any>;
type Dict<T = any> = Record<string, T>;
type TupleTypes<T> = {
    [P in keyof T]: T[P];
} extends {
    [key: number]: infer V;
} ? NullToObject<V> : never;
type NullToObject<T> = T extends null | undefined ? Record<any, any> : T;
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
type StripEnums<T extends Record<string, any>> = {
    [K in keyof T]: T[K] extends boolean ? T[K] : T[K] extends string ? T[K] : T[K] extends object ? T[K] : T[K] extends any[] ? T[K] : T[K] extends undefined ? undefined : any;
};

/**
 * Receives functions as arguments and returns a new function that calls all.
 * @example
 * const fnX = () => {}
 * const fnY = () => {}
 * const fnXY = chain(fnx, fnY)
 * fnXY() // same as fnX() fnY()
 */
declare function chain<T>(...fns: T[]): (...args: T extends AnyFunction ? Parameters<T> : never) => void;

/**
 * Returns a token as css variable
 */
declare function cssVar(props: CssVarProps): string;
interface CssVarProps {
    /**
     * Value of the foundation
     */
    token: string;
    /**
     * Search for the entire string
     * @default false
     */
    deepSearch?: boolean;
    /**
     * Prefix of the variable
     * @default 'sl'
     */
    prefix?: string;
}

type CxArgs = Array<string | null | undefined>;
/**
 * Spaces classNames properly
 * @param args: classnames to be combined
 * @returns {String} Classnames properly spaced
 * @example
 * cx('cn1', 'cn2') // returns => 'cn1 cn2'
 */
declare function cx(...args: CxArgs): string;

/**
 * Returns true if propName is a handler
 * @example
 * isNativeHandler('onChange') // true
 * isNativeHandler('handleChange') // false
 */
declare function isNativeHandler(propName: string): boolean;

/**
 * Returns wether a value is a function
 * @example
 * isFunction(() => {}) // true
 */
declare function isFunction<T extends AnyFunction = AnyFunction>(value: any): value is T;
/**
 * Returns wether a value is a string and is empty
 * @example
 * isStringEmpty('') => true
 * isStringEmpty(' ') => true
 */
declare function isStringEmpty<T extends string = string>(value: unknown): value is T;
/**
 * Returns wether a value is a string
 * @example
 * isString('') => true
 * isString(1) => false
 */
declare function isString<T extends string = string>(value: unknown): value is T;

type MergePropsArgs = AnyObject | null | undefined;
/**
 * Merges multiple props objects together combining classNames and chaining events.
 * @example
 * const propsA = {}
 * const propsB = {}
 * mergeProps(propsA, propsB)
 */
declare function mergeProps<T extends MergePropsArgs[]>(...args: T): UnionToIntersection<TupleTypes<T>>;

/**
 * Merges multiple refs into one. Works with either callback or object refs.
 * @example
 * const refA = useRef()
 * const refB = useRef()
 * const ref = mergeRefs(refA, refB)
 */
declare function mergeRefs(...refs: Array<ForwardedRef<any>>): ForwardedRef<any>;

declare function merge(...params: any): any;

declare function flattenObject<T extends AnyObject>(object: T, joinString?: string, defaultString?: string): Dict;

/**
 * Parse token from the config to a Token Dict.
 */
declare function parseTokens(props: ParseTokensProps): Dict;
interface ParseTokensProps {
    tokens: AnyObject;
    unprefixed?: boolean;
    prefix?: string;
}

/**
 * Returns wether a string is a token
 * @example
 * isToken('token') => false
 * isToken('$token') => true
 */
declare function isToken(token: unknown): token is string;
/**
 * Cleans the token symbol from a string
 * @param {String} token String to clean
 * @returns {String} Clean string
 * @example
 * cleanTokenString('$token') // returns => 'token'
 * cleanTokenString('token') // returns => 'token'
 */
declare function cleanTokenString(token: string): string;

declare const constants: {
    tokenPrefix: string;
    dsPrefix: string;
    comma: string;
    whiteSpace: string;
    emptyString: string;
};

/**
 * Augmented forwardRef function to support generics
 */
declare function forwardRef<T, P = AnyObject>(render: (props: P, ref: React.Ref<T>) => JSX.Element | null): (props: P & React.RefAttributes<T>) => JSX.Element | null;

/**
 * It's `true` if it is running in a browser environment or `false` if it is not
 * (SSR).
 * @example
 * const title = canUseDOM ? document.title : "";
 */
declare const canUseDOM: boolean;

/**
 * Generates a unique ID. Uses React's useId if available.
 */
declare function useId(defaultId?: string): string;

/**
 * Merges React Refs into a single memoized function ref so you can pass it to
 * an element.
 * @example
 * const Component = React.forwardRef((props, ref) => {
 *   const internalRef = React.useRef();
 *   return <div {...props} ref={useMergeRef(internalRef, ref)} />;
 * });
 */
declare function useMergeRef(...refs: Array<Ref<any> | undefined>): ((value: any) => void) | undefined;

/**
 * `React.useLayoutEffect` that fallbacks to `React.useEffect` on server side.
 */
declare const useSafeLayoutEffect: typeof React.useLayoutEffect;

/**
 * Returns true if the user is selecting some text
 */
declare function hasSomeTextSelected(): boolean;

/**
 * Parse a prefix-value to a CSS Variable declaration
 * @param {string} value
 * @param {string} prefix
 */
declare function toVar(value: string, prefix?: string): string;

declare function useControlledState<T, C = T>(value: Exclude<T, undefined>, defaultValue: Exclude<T, undefined> | undefined, onChange?: (v: C, ...args: any[]) => void): [T, (value: T) => void];
declare function useControlledState<T, C = T>(value: Exclude<T, undefined> | undefined, defaultValue: Exclude<T, undefined>, onChange?: (v: C, ...args: any[]) => void): [T, (value: T) => void];

interface ShorelineCSSProperties extends CSSProperties$1 {
    [key: `--${string}`]: string | number | boolean;
}
/**
 * Applies css variables on style
 * @example
 * <div style={style({ padding: '$space-3' })} />
 */
declare function style(cssProps: ShorelineCSSProperties): CSSProperties$1;

declare function shallowCompare<T>(objA: T, objB: T): boolean;

declare class Store<TState, TUpdater extends AnyUpdater = (cb: TState) => TState> {
    private listeners;
    private _state;
    private _options?;
    private _batching;
    private _flushing;
    constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>);
    get state(): TState;
    subscribe: (listener: Listener) => () => void;
    setState: (updater: TUpdater) => void;
    _flush: () => void;
    batch: (cb: () => void) => void;
}
type AnyUpdater = (...args: any[]) => any;
type Listener = () => void;
interface StoreOptions<TState, TUpdater extends AnyUpdater = (cb: TState) => TState> {
    updateFn?: (previous: TState) => (updater: TUpdater) => TState;
    onSubscribe?: (listener: Listener, store: Store<TState, TUpdater>) => () => void;
    onUpdate?: () => void;
}

type NoInfer<T> = [T][T extends any ? 0 : never];
declare function useStore<TState, TSelected = NoInfer<TState>, TUpdater extends AnyUpdater = AnyUpdater>(store: Store<TState, TUpdater>, selector?: (state: NoInfer<TState>) => TSelected): TSelected;

type CSSAbsoluteUnit = 'cm' | 'mm' | 'in' | 'px' | 'pt' | 'pc';
type CSSRelativeUnit = 'em' | 'rem' | 'ex' | 'ch' | 'vw' | 'vh' | 'vmin' | 'vmax' | '%';
type CSSUnit = CSSAbsoluteUnit | CSSRelativeUnit;
type CSSValueWithUnit = `${string}${CSSUnit}`;
type CSSValueAutocomplete<T extends string> = T | (string & {});
type CSSProperties = StandardProperties<number | string> & SvgProperties<number | string> & VendorProperties<number | string>;

export { type AnyFunction, type AnyObject, type CSSAbsoluteUnit, type CSSProperties, type CSSRelativeUnit, type CSSUnit, type CSSValueAutocomplete, type CSSValueWithUnit, type Dict, type ElementWithRef, type LiteralUnion, type NullToObject, type Primitive, type Recursive, type RenderProps, Store, type StripEnums, type TupleTypes, type UnionToIntersection, canUseDOM, chain, cleanTokenString, constants, cssVar, cx, flattenObject, forwardRef, hasSomeTextSelected, isFunction, isNativeHandler, isString, isStringEmpty, isToken, merge, mergeProps, mergeRefs, parseTokens, shallowCompare, style, toVar, useControlledState, useId, useMergeRef, useSafeLayoutEffect, useStore };
