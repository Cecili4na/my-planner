var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/constants.ts
var constants = {
  tokenPrefix: "$",
  dsPrefix: "sl",
  comma: ",",
  whiteSpace: " ",
  emptyString: ""
};

// src/is-types.ts
function isFunction(value) {
  return typeof value === "function";
}
function isStringEmpty(value) {
  return isString(value) && value.trim() === constants.emptyString;
}
function isString(value) {
  return typeof value === "string";
}

// src/chain.ts
function chain(...fns) {
  return (...args) => {
    for (const fn of fns) {
      if (isFunction(fn)) {
        fn(...args);
      }
    }
  };
}

// src/token.ts
function isToken(token) {
  return isString(token) && token.startsWith(constants.tokenPrefix);
}
function cleanTokenString(token) {
  if (isToken(token)) {
    const sanitizedToken = String(token).trim();
    return sanitizedToken.substring(1);
  }
  return token;
}

// src/css-var.ts
function cssVar(props) {
  const { token, deepSearch = false, prefix = constants.dsPrefix } = props;
  if (!token || isStringEmpty(token)) {
    return constants.emptyString;
  }
  if (deepSearch) {
    return _deepParse(token, prefix);
  }
  return tokenToVar(token, prefix);
}
function tokenToVar(token, prefix) {
  if (!isToken(token)) {
    return token;
  }
  const cleanedToken = cleanTokenString(token);
  if (cleanedToken.endsWith(constants.comma)) {
    return `var(--${prefix}-${cleanedToken.slice(0, -1)}),`;
  }
  return `var(--${prefix}-${cleanedToken})`;
}
function _deepParse(token, prefix) {
  const tokenizedValues = token.trim().split(constants.whiteSpace).map((value) => {
    return tokenToVar(value, prefix);
  });
  return tokenizedValues.join(constants.whiteSpace);
}

// src/cx.ts
function cx(...args) {
  const classNames = args.reduce((acc, argument) => {
    if (!argument) {
      return acc != null ? acc : constants.emptyString;
    }
    const trimmedArgument = argument.trim();
    const trimmedClassNames = `${acc}${constants.whiteSpace}${trimmedArgument}`.trim();
    return trimmedClassNames;
  }, constants.emptyString);
  return classNames != null ? classNames : constants.emptyString;
}

// src/is-native-handler.ts
function isNativeHandler(propName) {
  return propName[0] === "o" && propName[1] === "n" && propName.charCodeAt(2) >= /* 'A' */
  65 && propName.charCodeAt(2) <= /* 'Z' */
  90;
}

// src/merge-props.ts
function mergeProps(...args) {
  const mergedProps = __spreadValues({}, args[0]);
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    for (const prop in props) {
      const a = mergedProps[prop];
      const b = props[prop];
      if (isFunction(a) && isFunction(b) && isNativeHandler(prop)) {
        mergedProps[prop] = chain(a, b);
      } else if (prop === "className" && isString(a) && isString(b)) {
        mergedProps[prop] = cx(a, b);
      } else {
        mergedProps[prop] = b !== void 0 ? b : a;
      }
    }
  }
  return mergedProps;
}

// src/merge-refs.ts
function mergeRefs(...refs) {
  if (refs.length === 1) {
    return refs[0];
  }
  return (value) => {
    for (const ref of refs) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    }
  };
}

// src/merge.ts
import deepmerge from "deepmerge";
function merge(...params) {
  return deepmerge.all([...params].filter((p) => p));
}

// src/flatten-object.ts
function flattenObject(object, joinString = "-", defaultString = "*") {
  const result = {};
  for (const i in object) {
    if (typeof object[i] === "object" && !Array.isArray(object[i])) {
      const temp = flattenObject(object[i], joinString, defaultString);
      for (const j in temp) {
        if (j === defaultString) {
          result[`${i}`] = temp[j];
        } else {
          result[`${i}${joinString}${j}`] = temp[j];
        }
      }
    } else {
      result[i] = object[i];
    }
  }
  return result;
}

// src/to-var.ts
function toVar(value, prefix = constants.dsPrefix) {
  return `--${prefix}-${value}`;
}

// src/parse-tokens.ts
function parseTokens(props) {
  const { tokens = {}, unprefixed = false, prefix = constants.dsPrefix } = props;
  const flatTokens = flattenObject(tokens);
  const tokenDict = {};
  for (const key in flatTokens) {
    const token = flatTokens[key];
    const resultKey = unprefixed ? key : toVar(key, prefix);
    tokenDict[resultKey] = cssVar({ token, deepSearch: true, prefix });
  }
  return tokenDict;
}

// src/forward-ref.ts
import * as React from "react";
function forwardRef2(render) {
  return React.forwardRef(render);
}

// src/can-use-dom.ts
var canUseDOM = checkIsBrowser();
function checkIsBrowser() {
  var _a;
  return typeof window !== "undefined" && !!((_a = window.document) == null ? void 0 : _a.createElement);
}

// src/use-id.ts
import * as React3 from "react";

// src/use-safe-layout-effect.ts
import * as React2 from "react";
var useSafeLayoutEffect = canUseDOM ? React2.useLayoutEffect : React2.useEffect;

// src/use-id.ts
var _React = __spreadValues({}, React3);
var useReactId = _React.useId;
function useId(defaultId) {
  if (useReactId) {
    const reactId = useReactId();
    if (defaultId) return defaultId;
    return reactId;
  }
  const [id, setId] = React3.useState(defaultId);
  useSafeLayoutEffect(() => {
    if (defaultId || id) return;
    const random = Math.random().toString(36).substr(2, 6);
    setId(`id-${random}`);
  }, [defaultId, id]);
  return defaultId || String(id);
}

// src/use-merge-ref.ts
import { useMemo } from "react";
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function useMergeRef(...refs) {
  return useMemo(() => {
    if (!refs.some(Boolean)) return;
    return (value) => {
      refs.forEach((ref) => {
        setRef(ref, value);
      });
    };
  }, refs);
}

// src/has-some-text-selected.ts
function hasSomeTextSelected() {
  var _a, _b;
  if (!canUseDOM) return false;
  return !!((_b = (_a = window == null ? void 0 : window.getSelection) == null ? void 0 : _a.call(window)) == null ? void 0 : _b.toString());
}

// src/string-case.ts
import {
  pascalCase,
  camelCase,
  kebabCase,
  snakeCase,
  isUppercase,
  lowerFirst,
  splitByCase,
  upperFirst
} from "scule";

// src/invariant.ts
import invariant from "tiny-invariant";

// src/warning.ts
import warning from "tiny-warning";

// src/use-controlled-state.ts
import { useCallback, useEffect as useEffect2, useRef, useState as useState2 } from "react";
function useControlledState(value, defaultValue, onChange) {
  const [stateValue, setStateValue] = useState2(value || defaultValue);
  const isControlledRef = useRef(value !== void 0);
  const isControlled = value !== void 0;
  useEffect2(() => {
    const wasControlled = isControlledRef.current;
    if (wasControlled !== isControlled) {
      console.warn(
        `WARN: A component changed from ${wasControlled ? "controlled" : "uncontrolled"} to ${isControlled ? "controlled" : "uncontrolled"}.`
      );
    }
    isControlledRef.current = isControlled;
  }, [isControlled]);
  let currentValue = isControlled ? value : stateValue;
  const setValue = useCallback(
    (value2, ...args) => {
      const onChangeCaller = (value3, ...onChangeArgs) => {
        if (onChange) {
          if (!Object.is(currentValue, value3)) {
            onChange(value3, ...onChangeArgs);
          }
        }
        if (!isControlled) {
          currentValue = value3;
        }
      };
      if (typeof value2 === "function") {
        console.warn(
          "We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320"
        );
        const updateFunction = (oldValue, ...functionArgs) => {
          const interceptedValue = value2(
            isControlled ? currentValue : oldValue,
            ...functionArgs
          );
          onChangeCaller(interceptedValue, ...args);
          if (!isControlled) {
            return interceptedValue;
          }
          return oldValue;
        };
        setStateValue(updateFunction);
      } else {
        if (!isControlled) {
          setStateValue(value2);
        }
        onChangeCaller(value2, ...args);
      }
    },
    [isControlled, currentValue, onChange]
  );
  return [currentValue, setValue];
}

// src/style.ts
function style(cssProps) {
  const result = {};
  for (const prop in cssProps) {
    const value = cssProps[prop];
    const variable = typeof value === "string" ? cssVar({ token: String(value), deepSearch: true }) : value;
    result[prop] = variable;
  }
  return result;
}

// src/shallow-compare.ts
function shallowCompare(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

// src/store.ts
var Store = class {
  constructor(initialState, options) {
    this.listeners = /* @__PURE__ */ new Set();
    this._batching = false;
    this._flushing = 0;
    this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this._options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener);
        unsub == null ? void 0 : unsub();
      };
    };
    this.setState = (updater) => {
      var _a, _b, _c;
      const previous = this._state;
      this._state = ((_a = this._options) == null ? void 0 : _a.updateFn) ? this._options.updateFn(previous)(updater) : updater(previous);
      (_c = (_b = this._options) == null ? void 0 : _b.onUpdate) == null ? void 0 : _c.call(_b);
      this._flush();
    };
    this._flush = () => {
      if (this._batching) return;
      const flushId = ++this._flushing;
      this.listeners.forEach((listener) => {
        if (this._flushing !== flushId) return;
        listener();
      });
    };
    this.batch = (cb) => {
      if (this._batching) return cb();
      this._batching = true;
      cb();
      this._batching = false;
      this._flush();
    };
    this._state = initialState;
    this._options = options;
  }
  get state() {
    return this._state;
  }
};

// src/use-store.ts
import { useSyncExternalStoreWithSelector } from "use-sync-external-store/shim/with-selector.js";
function useStore(store, selector = (d) => d) {
  const slice = useSyncExternalStoreWithSelector(
    store.subscribe,
    () => store.state,
    () => store.state,
    selector,
    shallowCompare
  );
  return slice;
}
export {
  Store,
  camelCase,
  canUseDOM,
  chain,
  cleanTokenString,
  constants,
  cssVar,
  cx,
  flattenObject,
  forwardRef2 as forwardRef,
  hasSomeTextSelected,
  invariant,
  isFunction,
  isNativeHandler,
  isString,
  isStringEmpty,
  isToken,
  isUppercase,
  kebabCase,
  lowerFirst,
  merge,
  mergeProps,
  mergeRefs,
  parseTokens,
  pascalCase,
  shallowCompare,
  snakeCase,
  splitByCase,
  style,
  toVar,
  upperFirst,
  useControlledState,
  useId,
  useMergeRef,
  useSafeLayoutEffect,
  useStore,
  warning
};
//# sourceMappingURL=index.js.map